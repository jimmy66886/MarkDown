2023年8月25日 16点04分

**这应该是写在简历上的项目了,待好好对待啊**

# 1 项目概述&环境搭建

技术选型
![20230826093518](https://gcore.jsdelivr.net/gh/jimmy66886/picgo_two@main/img/20230826093518.png)

## 前端环境搭建

?好像也没搭建啥,直接打开资料,双击nginx就ok了
![20230826102250](https://gcore.jsdelivr.net/gh/jimmy66886/picgo_two@main/img/20230826102250.png)

## 后端环境搭建

这后端代码已经写好一大部分了啊
![20230826102836](https://gcore.jsdelivr.net/gh/jimmy66886/picgo_two@main/img/20230826102836.png)
1. `sky-take-out`:maven父工程,统一管理依赖版本,聚合其他子模块
2. `sky-common`:子模块,存放公共类,例如:工具类,常量类,异常类等
3. `sky-pojo`:子模块,存放实体类,VO,DTO等
4. `sky-server`:子模块,后端服务,存放配置文件,Controller,Service,Mapper等

---

`sky-pojo`模块介绍
![20230826103421](https://gcore.jsdelivr.net/gh/jimmy66886/picgo_two@main/img/20230826103421.png)
- `Entity`:实体,通常和数据库中的表对应
- `DTO`:数据传输对象,通常用于程序中各层之间传递数据
- `VO`:视图对象,为前端展示数据提供的对象
- `pojo`:普通Java对象,只有属性和对应的getter和etter

---

>**使用Git进行版本控制**

害,这比网,推了半天都推不到github上

推上去了,[仓库地址](https://github.com/jimmy66886/sky-take-out)

## 数据库环境搭建

这个比较好哎,有一个sql外加一个数据库设计文档

各个表介绍
![20230826110410](https://gcore.jsdelivr.net/gh/jimmy66886/picgo_two@main/img/20230826110410.png)

## 前后端联调

后端的初始工程中已经实现了登录功能,直接进行前后端联调测试

这里用到了**全局异常处理**
```java
package com.sky.handler;

import com.sky.exception.BaseException;
import com.sky.result.Result;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

/**
 * 全局异常处理器，处理项目中抛出的业务异常
 */
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    /**
     * 捕获业务异常
     * @param ex
     * @return
     */
    @ExceptionHandler
    public Result exceptionHandler(BaseException ex){
        log.error("异常信息：{}", ex.getMessage());
        return Result.error(ex.getMessage());
    }

}
```

在用户登录接口中,会抛出一个异常:
```java
        if (employee == null) {
            //账号不存在
            throw new AccountNotFoundException(MessageConstant.ACCOUNT_NOT_FOUND);
        }
```

这里如果出现异常,就会被`GlobalExceptionHandler`捕获到,**抛出的是AccountNotFoundException,能被Global捕获是因为该异常继承自BaseException**
```java
public class AccountNotFoundException extends BaseException {
}
```

---

下面用到了Builder,可以用来创建对象,特点是**方法名即为属性名,使用前提是实体类上加上`@Builder`注解**
```java
        EmployeeLoginVO employeeLoginVO = EmployeeLoginVO.builder()
                .id(employee.getId())
                .userName(employee.getUsername())
                .name(employee.getName())
                .token(token)
                .build();
```

## Nginx反向代理与负载均衡

**反向代理**

刚看了Nginx的配置文件,原来是用了反向代理

前端请求地址:`http://localhost/api/employee/login`
后端接口地址:`http://localhost:8080/admin/employee/login`

所谓反向代理,就是将前端发送的动态请求由nginx转发到后端服务器

使用nginx的好处:
1. 提高访问速度
    - nginx会对请求地址进行缓存,相同的请求不必再发送至后端*那后端数据变了怎么办?*
2. 进行负载均衡
    - 所谓负载均衡,就是把大量的请求按照我们指定的方式均衡的分配给集群中的每台服务器
3. 保证后端服务安全
    - 后端服务不暴露到外网


该项目中的反向代理:
```conf
server {
        listen       80;
        server_name  localhost;

        # 反向代理,处理管理端发送的请求
        location /api/ {
			proxy_pass   http://localhost:8080/admin/;
        }
}
```

就相当于,前端请求的`http://localhost/api`,会被转发到`http://localhost:8080/admin/`,后面的`employee/login`是不变的

---

**负载均衡**
```conf
upstream webservers{
	  server 127.0.0.1:8080 weight=90 ;
	  #server 127.0.0.1:8088 weight=10 ;
}

server{
    listen 80;
    server_name localhost;

    location /api/{
        proxy_pass http://webservers/amdin/; # 负载均衡
    }
}

```

请求过来时,`localhost:80/api/xxxx`会被转发到`http://webservers/amdin/xxx`,而这个`webservers`就是配置中的多个`server`,nginx会对这些server进行分配,`server`后面加上`weight`表示权重,这是一种负载均衡的策略
![20230826170157](https://gcore.jsdelivr.net/gh/jimmy66886/picgo_two@main/img/20230826170157.png)

## 完善登录功能

现在的问题:**密码明文存储**
1. 将密码加密后存储,提高安全性
2. 使用MD5加密方式对明文密码加密

123456加密后为:`e10adc3949ba59abbe56e057f20f883e`

依稀记得之前还自己写md5加密的代码,原来spring自带啊,一行代码就完成了
```java
        // TODO 后期需要进行md5加密，然后再进行比对
        password = DigestUtils.md5DigestAsHex(password.getBytes());
```

md5DigestAsHex()函数就是将字符串(的bytes)进行md5加密

## Swagger

在这之前还引入了yapi,不过暂时用不到

这一小节可以放到我的**开发工具箱里**

使用Swagger只需要按照它的规范去定义接口及接口相关的信息，就可以做到生成接口文档，以及**在线接口调试**页面,`Knife4j`是为Java MVC框架集成Swagger生成Api文档的增强解决方案

**使用方式**

1. 导入依赖
```xml
        <dependency>
            <groupId>com.github.xiaoymin</groupId>
            <artifactId>knife4j-spring-boot-starter</artifactId>
            <version>3.0.2</version>
        </dependency>
```
2. 在配置类中加入`knife4j`相关配置(某个带有`@Configuration`的配置类中即可)
```java
    /**
     * 通过knife4j生成接口文档
     * @return
     */
    @Bean
    public Docket docket() {
        ApiInfo apiInfo = new ApiInfoBuilder()
                .title("苍穹外卖项目接口文档")
                .version("2.0")
                .description("苍穹外卖项目接口文档")
                .build();
        Docket docket = new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo)
                .select()
                .apis(RequestHandlerSelectors.basePackage("com.sky.controller"))
                .paths(PathSelectors.any())
                .build();
        return docket;
    }
```
3. 设置静态资源映射,否则接口文档页面无法访问(要放在某个继承自`WebMvcConfigurationSupport`类中),这个方法其实就是重写的父类的方法
![20230826201101](https://gcore.jsdelivr.net/gh/jimmy66886/picgo_two@main/img/20230826201101.png)
```java
    /**
     * 设置静态资源映射
     * @param registry
     */
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/doc.html").addResourceLocations("classpath:/META-INF/resources/");
        registry.addResourceHandler("/webjars/**").addResourceLocations("classpath:/META-INF/resources/webjars/");
    }
```

顺便把这个配置类也放着:
```java
package com.sky.config;

import com.sky.interceptor.JwtTokenAdminInterceptor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;

/**
 * 配置类，注册web层相关组件
 */
@Configuration
@Slf4j
public class WebMvcConfiguration extends WebMvcConfigurationSupport {

    @Autowired
    private JwtTokenAdminInterceptor jwtTokenAdminInterceptor;

    /**
     * 注册自定义拦截器
     *
     * @param registry
     */
    protected void addInterceptors(InterceptorRegistry registry) {
        log.info("开始注册自定义拦截器...");
        registry.addInterceptor(jwtTokenAdminInterceptor)
                .addPathPatterns("/admin/**")
                .excludePathPatterns("/admin/employee/login");
    }

    /**
     * 通过knife4j生成接口文档
     * @return
     */
    @Bean
    public Docket docket() {
        ApiInfo apiInfo = new ApiInfoBuilder()
                .title("苍穹外卖项目接口文档")
                .version("2.0")
                .description("苍穹外卖项目接口文档")
                .build();
        Docket docket = new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo)
                .select()
                .apis(RequestHandlerSelectors.basePackage("com.sky.controller"))
                .paths(PathSelectors.any())
                .build();
        return docket;
    }

    /**
     * 设置静态资源映射
     * @param registry
     */
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/doc.html").addResourceLocations("classpath:/META-INF/resources/");
        registry.addResourceHandler("/webjars/**").addResourceLocations("classpath:/META-INF/resources/webjars/");
    }
}
```

---

这就配置好了,启动项目进入浏览器访问`localhost:8080/doc.html`,即可进入接口文档页面
![20230826201533](https://gcore.jsdelivr.net/gh/jimmy66886/picgo_two@main/img/20230826201533.png)

---

>Swagger和yapi的区别
1. yapi是**设计阶段**使用的工具,管理和维护接口
2. Swagger是在**开发阶段**使用的框架,帮助后端开发人员做后端的接口测试

### Swagger常用注解

![20230826202517](https://gcore.jsdelivr.net/gh/jimmy66886/picgo_two@main/img/20230826202517.png)

具体使用案例

1. `@Api(tags = "员工相关接口")`,给Controller上加,在页面上表示一级目录,**tags=**不能省略,否则无效,
```java
@Api(tags = "员工相关接口")
public class EmployeeController {
}
```
2. `@ApiOperation(value = "员工登录接口")`,给接口上加,表示具体接口的名称
```java
@ApiOperation(value = "员工登录接口")
public Result<EmployeeLoginVO> login(@RequestBody EmployeeLoginDTO employeeLoginDTO) {
}
```
3. `@ApiModel`和`@ApiModelProperty()`,给实体类和属性上加
```java
@ApiModel(description = "员工登录时传递的数据模型")
public class EmployeeLoginDTO implements Serializable {

    @ApiModelProperty("用户名")
    private String username;

    @ApiModelProperty("密码")
    private String password;

}
```

# 员工管理

## 新增员工

产品原型:
![20230826222241](https://gcore.jsdelivr.net/gh/jimmy66886/picgo_two@main/img/20230826222241.png)

这里又说了一下`DTO`的用处,我们的实体类是跟数据库进行映射的,而`DTO`,是用来封装前端接收的信息的,这个`EmployeeDTO`,就是用来封装新增员工信息的,我们的实体类中的属性要比`DTO`多一些(上面那个登录的DTO,也是和登录信息有关的)
![20230826223342](https://gcore.jsdelivr.net/gh/jimmy66886/picgo_two@main/img/20230826223342.png)

---

**代码开发**

>Controller,调用service的save方法,然后返回成功
```java
    @PostMapping
    @ApiOperation("新增员工")
    public Result save(@RequestBody EmployeeDTO employeeDTO) {
        log.info("新增员工信息：{}", employeeDTO);

        employeeService.save(employeeDTO);
        return Result.success();
    }
```
>Service
1. 就像下面说的,虽然接收前端的数据的是DTO,但是和数据库进行交互还是用实体类,所以这里涉及到类型转换,用`BeanUtils.copyProperties(source,target)`能够很方便的copy对象,**前提是属性名一致**
2. 密码是默认的,为`123456`,存入数据库的要进行md5加密
```java
/**
     * 新增员工
     *
     * @param employeeDTO
     */
    @Override
    public void save(EmployeeDTO employeeDTO) {

        // 虽然前端传来的是DTO,但是还是建议跟数据交互时使用实体类,所以这里要进行类型转换
        Employee employee = new Employee();

        // 对象属性拷贝--如果使用set一个一个写，是很繁琐的
        // 前提是属性名一致
        BeanUtils.copyProperties(employeeDTO, employee);

        // 设置账号的状态 1 表示正常，这里使用常量类，防止硬编码
        employee.setStatus(StatusConstant.ENABLE);
        // 密码默认为123456-md5加密后再存
        employee.setPassword(DigestUtils.md5DigestAsHex(PasswordConstant.DEFAULT_PASSWORD.getBytes()));

        // 设置当前记录的创建和修改时间
        employee.setCreateTime(LocalDateTime.now());
        employee.setUpdateTime(LocalDateTime.now());

        // 设置记录的创建人id和修改人id
        // TODO 后期需要改为当前登录用户的id
        employee.setCreateUser(10L);
        employee.setCreateUser(10L);

        employeeMapper.save(employee);
    }
```
>Mapper,这个就没什么说的了.
```java
    /**
     * 插入员工数据
     *
     * @param employee
     */
    @Insert("insert into employee(name,username,password,phone,sex,id_number,create_time,update_time,create_user," +
            "update_user,status) " +
            "values(#{name},#{username},#{password},#{phone},#{sex},#{idNumber},#{createTime},#{updateTime}," +
            "#{createUser},#{updateUser},#{status})")
    void save(Employee employee);
```

*明天见*

>**代码完善**

目前存在的问题
1. 录入的用户名存在,抛出异常后没有处理
2. 新增员工时,创建人id和修改人id设置为了固定值

解决第一个问题,使用异常处理
```java
    @ExceptionHandler
    public Result exceptionHandler(SQLIntegrityConstraintViolationException ex) {
        // Duplicate entry 'admin' for key 'employee.idx_username'
        String message = ex.getMessage();
        if (message.contains("Duplicate entry")) {
            String[] messageArr = message.split(" ");
            String repeatName = messageArr[2];
            // return Result.error(repeatName + "该用户名已存");
            return Result.error(repeatName + MessageConstant.ALREADY_EXISTS);
        } else {
            return Result.error(MessageConstant.UNKNOWN_ERROR);
        }
    }
```

由于`用户名存在`导致sql执行时的唯一性的问题,会报错:`Duplicate entry 'admin' for key 'employee.idx_username`,所以我们可以根据这个异常信息来获取需要的内容,最终封装返回结果

---

解决第二个问题

这里就涉及到Jwt Token了,之前用过,但是说实话,我并不是很清楚怎么用
![20230827101540](https://gcore.jsdelivr.net/gh/jimmy66886/picgo_two@main/img/20230827101540.png)

**可以通过解析请求头中的token,来得到是哪个用户发起的请求**
但是获取到之后,如何传递给service?

所以引入`ThreadLocal`,`ThreadLocal`并不是一个`Thread`,而是`Thread`的局部变量
`ThreadLocal`为每个线程提供单独一份存储空间,具有线程隔离的效果,只有在线程内才能获取到对应的值,线程外则不能访问

**每次请求,都是同一个线程**

>**ThreadLocal**常用方法
1. `public void set(T value)` 设置当前线程的线程局部变量的值
2. `public T get()` 返回当前线程对应的线程局部变量的值
3. `public void remove()` 移除当前线程的线程局部变量

这里使用了一个工具类:
```java
package com.sky.context;

public class BaseContext {

    public static ThreadLocal<Long> threadLocal = new ThreadLocal<>();

    public static void setCurrentId(Long id) {
        threadLocal.set(id);
    }

    public static Long getCurrentId() {
        return threadLocal.get();
    }

    public static void removeCurrentId() {
        threadLocal.remove();
    }

}
```

一共两处修改:
1. JwtTokenAdminInterceptor拦截器,在拿到token中的empId时,将该empId存入ThreadLocal中
```java
// 2、校验令牌
        try {
            log.info("jwt校验:{}", token);
            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);
            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());
            log.info("当前员工id：{}", empId);
            // 将empId存入ThreadLocal
            BaseContextByMe.setCurrentId(empId);
            // 3、通过，放行
            return true;
        } catch (Exception ex) {
            // 4、不通过，响应401状态码
            response.setStatus(401);
            return false;
        }
```
2. Service中,在设置登录用户的id处,取出ThreadLocal中的empId
```java
        // 设置记录的创建人id和修改人id
        // 从ThreadLocal中获取到登录用户的id
        Long empId = BaseContextByMe.getCurrentId();
        employee.setCreateUser(empId);
        employee.setUpdateUser(empId);

```

## 员工分页查询

>业务规则
1. 根据页码展示员工信息
2. 每页展示10条数据
3. 分页查询时可以根据需要,输入员工姓名进行查询

---

这里封装了一个PageResult对象,**后面所有的分页查询,统一都封装成PageResult对象**,然后最后返回给前端的还是Result,为`Result<PageResult>`
```java
/**
 * 封装分页查询结果
 */
@Data
@AllArgsConstructor
@NoArgsConstructor
public class PageResult implements Serializable {

    private long total; //总记录数

    private List records; //当前页数据集合

}

```

使用到的分页插件
```xml
        <dependency>
            <groupId>com.github.pagehelper</groupId>
            <artifactId>pagehelper-spring-boot-starter</artifactId>
        </dependency>
```

感觉这个分页插件和mp的分页区别挺大的,但是说实话,我现在并不太想用mp,这玩意弱化sql的能力哎.

**代码开发**

>Controller,这里是直接拿请求参数的,不是请求体,所以不用`@RequestBody`注解,用到的EmployeePageQueryDTO也是非常简单
```java
@Data
public class EmployeePageQueryDTO implements Serializable {

    //员工姓名
    private String name;

    //页码
    private int page;

    //每页显示记录数
    private int pageSize;

}
```
```java
    @GetMapping("/page")
    @ApiOperation("员工分页查询")
    public Result<PageResult> page(EmployeePageQueryDTO employeePageQueryDTO) {
        log.info("员工分页查询,参数为：{}", employeePageQueryDTO);
        PageResult pageResult = employeeService.pageQuery(employeePageQueryDTO);
        return Result.success(pageResult);
    }
```
>Service中,使用到了`PageHelper`,重点在于`PageHelper.startPage(employeePageQueryDTO.getPage(), employeePageQueryDTO.getPageSize());`,第一个参数是当前页,第二个参数是每页个数,这两个参数都是前端传来的.最后调用mapper查询数据库
```java
    /**
     * 分页查询
     *
     * @return
     */
    @Override
    public PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO) {

        // 开发分页查询
        PageHelper.startPage(employeePageQueryDTO.getPage(), employeePageQueryDTO.getPageSize());
        Page<Employee> page = employeeMapper.pageQuery(employeePageQueryDTO);
        // 这乍一看感觉Page和PageHelper没有传递参数的关系，但是其实startPage里面是用到了ThreadLocal来取值的

        long total = page.getTotal();
        List<Employee> records = page.getResult();
        return new PageResult(total, records);
    }
```
>Mapper,因为使用了分页插件,这个分页插件会动态的拼接limit,所以这里不用再写limit了,只需要拼接可选参数姓名即可
```xml
    <!-- Page<Employee> pageQuery(EmployeePageQueryDTO employeePageQueryDTO); -->
        <select id="pageQuery" resultType="com.sky.entity.Employee">
        select * from employee
        <where>
            <if test="name!=''and name!=null">
                name like concat('%',#{name},'%')
            </if>
        </where>
        order by create_time DESC
    </select>
```

测试整体没什么问题,但是返回的create_time,也就是日期格式有问题
```json
{
  "code": 1,
  "msg": null,
  "data": {
    "total": 5,
    "records": [
      {
        "id": 3,
        "username": "lisi",
        "name": "李四",
        "password": "e10adc3949ba59abbe56e057f20f883e",
        "phone": "17513571211",
        "sex": "0",
        "idNumber": "412827200104013984",
        "status": 1,
        "createTime": [
          2023,
          8,
          26,
          23,
          46,
          12
        ],
        "updateTime": [
          2023,
          8,
          26,
          23,
          46,
          12
        ],
        "createUser": 10,
        "updateUser": null
      },
      {
        "id": 2,
        "username": "zhuozhuo",
        "name": "灼灼",
        "password": "e10adc3949ba59abbe56e057f20f883e",
        "phone": "17513741212",
        "sex": "1",
        "idNumber": "111111112313213",
        "status": 1,
        "createTime": [
          2023,
          8,
          26,
          23,
          38,
          16
        ],
        "updateTime": [
          2023,
          8,
          26,
          23,
          38,
          16
        ],
        "createUser": 10,
        "updateUser": null
      }
    ]
  }
}
```
前端展示的是一个字符串:
![20230827142346](https://gcore.jsdelivr.net/gh/jimmy66886/picgo_two@main/img/20230827142346.png)

**代码完善**

解决方式有以下两种
1. 在属性上加入注解,对日期进行格式化
```java
@JsonFormt(pattern = "yyyy-MM-dd HH:mm:ss")
private LocalDateTime updateTime;
```
2. 在WebMvcConfiguration中扩展SpringMVC的消息转换器,统一对日期类型进行格式化处理(**推荐使用,一劳永逸**)
```java
    /**
     * 扩展SpringMVC框架的消息转换器
     * 对后端返回给前端的数据进行 统一 的处理
     *
     * @param converters the list of configured converters to extend
     */
    @Override
    protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
        log.info("扩展消息转换器-用于日期格式化");
        // 创建一个消息转换对象
        MappingJackson2HttpMessageConverter converter =
                new MappingJackson2HttpMessageConverter();
        // 需要为消息转换器设置一个对象转换器,可以将Java对象序列化为json数据
        converter.setObjectMapper(new JacksonObjectMapper());
        // 将自己的消息转换器加入到容器中,第一个参数是代表索引,也即是这个转换器的优先级,越小越高
        converters.add(0, converter);

    }
```

ok,员工分类查询结束

## 启用/禁用员工账号

这个整体还是简单许多的,就是接受前端发来的状态,已经要修改的员工id

>Controller,**路径参数要用注解来获取，而地址栏传参不需要加注解**
```java
    /**
     * 启用/禁用员工账号
     * 参数有两个，一个是路径参数，路径参数要用注解来获取，而地址栏传参不需要加注解
     *
     * @param status
     * @param id
     * @return
     */
    @PostMapping("/status/{status}")
    @ApiOperation("启用/禁用员工账号")
    public Result startOrStop(@PathVariable("status") Integer status, Long id) {
        log.info("启用/禁用员工账号： status:{}, id:{}", status, id);
        employeeService.startOrStop(status,id);
        return Result.success();
    }
```
>Service,这里也用到了Builder,update方法可以根据传入对象的id,修改任意的字段-动态sql
```java
    /**
     * 启用/禁用员工账号
     *
     * @param status
     * @param id
     */
    @Override
    public void startOrStop(Integer status, Long id) {

        Employee employee = Employee.builder().id(id).status(status).build();

        employeeMapper.update(employee);
    }
```
>Mapper,这里还不能写成`test="username != null and username != ''"`,还必须只能写成这样的..
```xml
<!--    void update(Employee employee);-->
    <update id="update">
        update employee
<set>
            <if test="username != null">
                username = #{username},
            </if>
            <if test="password != null">
                password = #{password},
            </if>
            <if test="phone != null">
                phone = #{phone},
            </if>
            <if test=" sex != null">
                sex = #{sex},
            </if>
            <if test="idNumber != null">
                id_number = #{idNumber},
            </if>
            <if test="updateTime != null">
                update_time = #{updateTime},
            </if>
            <if test="updateUser != null">
                update_user = #{updateUser},
            </if>
            <if test="status!=null">
                status = #{status},
            </if>
            <if test="name!=null">
                name = #{name},
            </if>
        </set>
        where id = #{id}
    </update>
```

## 编辑员工

编辑员工功能涉及到两个接口
1. 根据id查询员工信息
>Controller
这个还是很简单的
```java
    /**
     * 根据id查询员工信息
     *
     * @param id
     * @return
     */
    @GetMapping("/{id}")
    @ApiOperation("根据id查询员工信息")
    public Result<Employee> getById(@PathVariable Long id) {
        Employee employee = employeeService.getById(id);
        return Result.success(employee);
    }
```
>Service,主要就是注意密码要重写一遍,不能直接发过去,就算是加密过的也不能发
```java
    /**
     * 根据id查询员工信息
     *
     * @param id
     * @return
     */
    @Override
    public Employee getById(Long id) {
        Employee employee = employeeMapper.getById(id);
        // 密码不会发送到前端
        employee.setPassword("****");
        return employee;
    }
```
2. 编辑员工信息
>Controller,还是使用的`EmployeeDTO`
```java
    @PutMapping
    @ApiOperation("编辑员工信息")
    public Result update(@RequestBody EmployeeDTO employeeDTO) {
        employeeService.update(employeeDTO);
        return Result.success();
    }
```
>Service,首先创建一个employee对象,因为给数据库存数据都是用的实体类,这里又用到了`BeanUtils`来copy对象,最后再把`ThreadLocal`中的当前用户id,也就是`谁更新的`设置进来,再用上面更新员工状态的`update`方法即可.
```java
    /**
     * 修改员工信息
     *
     * @param employeeDTO
     */
    @Override
    public void update(EmployeeDTO employeeDTO) {
        Employee employee = new Employee();
        BeanUtils.copyProperties(employeeDTO, employee);

        employee.setUpdateTime(LocalDateTime.now());
        employee.setUpdateUser(BaseContextByMe.getCurrentId());

        employeeMapper.update(employee);
    }
```

# 分类管理

## 设计

1. 分类名称必须**唯一**
2. 分类按照类型可以分为**菜品分类**和**套餐分类**
3. 新添加的分类状态默认为**禁用**

## 接口

1. 新增分类
2. 分类分页查询
3. 根据id删除分类
4. 修改分类
5. 启用禁用分类
6. 根据类型查询分类

老师的意思是直接cv了,因为整体逻辑和员工管理差不多,我自己写一遍吧

### 新增分类

>Controller,直接用categoryDTO接收前端发来的信息
```java
    /**
     * 新增分类信息
     *
     * @param categoryDTO
     * @return
     */
    @PostMapping
    @ApiOperation("新增分类信息")
    public Result save(@RequestBody CategoryDTO categoryDTO) {
        categoryService.save(categoryDTO);
        return Result.success();
    }
```
>Service,既然是新增,加到数据库的依然是`Category`而不是`CategoryDTO`,所以这里要进行类型转换,注意新增的类型是默认禁止的,最后取出修改创建人的id一起封装
```java
    @Override
    public void save(CategoryDTO categoryDTO) {
        Category category = new Category();
        BeanUtils.copyProperties(categoryDTO, category);

        // 新增的菜单默认是禁止的
        category.setStatus(StatusConstant.DISABLE);

        // 然后是创建时间，修改时间，创建人，修改人
        category.setCreateTime(LocalDateTime.now());
        category.setUpdateTime(LocalDateTime.now());
        category.setCreateUser(BaseContextByMe.getCurrentId());
        category.setUpdateUser(BaseContextByMe.getCurrentId());

        categoryMapper.insert(category);
    }
```

### 分类分页查询

>Controller,遇到分页查询,既需要用`PageResult`
```java
    /**
     * 分类分页查询，请求参数有name分类名称,page,pageSize,type分类类型
     *
     * @return
     */
    @GetMapping("/page")
    @ApiOperation("分类分页查询")
    public Result<PageResult> page(CategoryPageQueryDTO categoryPageQueryDTO) {
        PageResult pageResult = categoryService.pageQuery(categoryPageQueryDTO);
        return Result.success(pageResult);
    }
```
>Service,这个接口依然不算难,照着之前写的那个就能写
```java
    /**
     * 分类分页查询
     *
     * @param categoryPageQueryDTO
     * @return
     */
    @Override
    public PageResult pageQuery(CategoryPageQueryDTO categoryPageQueryDTO) {

        PageHelper.startPage(categoryPageQueryDTO.getPage(), categoryPageQueryDTO.getPageSize());
        Page<Category> page = categoryMapper.pageQuery(categoryPageQueryDTO);

        long total = page.getTotal();
        List<Category> records = page.getResult();
        return new PageResult(total, records);
    }
```
>Mapper,也是常规的内容,注意分类名要模糊查询,而分类类型是直接判断
```xml
    <select id="pageQuery" resultType="com.sky.entity.Category">
        select * from category
        <where>
            <if test="name != null and name != ''">
                name like concat('%',#{name},'%')
            </if>
            <if test="type != null and type != ''">
                and type = #{type}
            </if>
        </where>
        order by sort asc , create_time desc
    </select>
```
### 根据id删除分类

>Controller,那就直接调用service进行删除
```java
    /**
     * 删除分类
     *
     * @param id
     * @return
     */
    @DeleteMapping
    @ApiOperation("删除分类")
    public Result<String> deleteById(Long id) {
        categoryService.deleteById(id);
        return Result.success();
    }
```
>Service,**主要就是注意分类是否包含菜品或套餐**,引入另外的两个mapper,来根据分类id查询归属该分类的数量
```java
/**
     * 根据id删除分类
     * 但是要注意该分类中是否关联了菜品，如果关联了就不能删除
     * 还要注意是否关联了套餐
     *
     * @param id
     */
    @Override
    public void deleteById(Long id) {

        Integer count = dishMapper.countByCategoryId(id);

        if (count > 0) {
            // 该分类中有菜品，不能删除
            throw new DeletionNotAllowedException(MessageConstant.CATEGORY_BE_RELATED_BY_DISH);
        }

        count = setmealMapper.countByCategoryId(id);
        if (count > 0) {
            // 该分类中有套餐，不能删除
            throw new DeletionNotAllowedException(MessageConstant.CATEGORY_BE_RELATED_BY_SETMEAL);
        }
        // 没问题了就删除该分类数据
        categoryMapper.deleteById(id);
    }
```
### 修改分类

>Controller,直接传,没什么好说的
```java
    /**
     * 修改分类
     * @param categoryDTO
     * @return
     */
    @PutMapping
    @ApiOperation("修改分类")
    public Result update(@RequestBody CategoryDTO categoryDTO) {
        categoryService.update(categoryDTO);
        return Result.success();
    }
```
>Service,主要是将`categoryDTO`封装为`category`
```java
    /**
     * 修改分类信息
     *
     * @param categoryDTO
     */
    @Override
    public void update(CategoryDTO categoryDTO) {
        Category category = new Category();
        BeanUtils.copyProperties(categoryDTO, category);

        category.setUpdateUser(BaseContextByMe.getCurrentId());
        category.setUpdateTime(LocalDateTime.now());

        categoryMapper.update(category);

    }
```
>Mapper
```xml
<update id="update" parameterType="Category">
        update category
        <set>
            <if test="type != null">
                type = #{type},
            </if>
            <if test="name != null">
                name = #{name},
            </if>
            <if test="sort != null">
                sort = #{sort},
            </if>
            <if test="status != null">
                status = #{status},
            </if>
            <if test="updateTime != null">
                update_time = #{updateTime},
            </if>
            <if test="updateUser != null">
                update_user = #{updateUser}
            </if>
        </set>
        where id = #{id}
    </update>
```

### 启用禁用分类

>Controller,也是和之前一样
```java
/**
     * 修改分类状态
     * @param status
     * @param id
     * @return
     */
    @PostMapping("/status/{status}")
    public Result startOrStop(@PathVariable Integer status, Long id) {
        categoryService.startOrStop(status, id);
        return Result.success();
    }
```
>Service
```java
    /**
     * 禁用/启用 分类状态
     *
     * @param status
     * @param id
     */
    @Override
    public void startOrStop(Integer status, Long id) {
        Category category =
                Category.builder().id(id).status(status)
                        .updateTime(LocalDateTime.now()).updateUser(BaseContextByMe.getCurrentId()).
                        build();
        categoryMapper.update(category);
    }
```

### 根据类型查询分类

>Controller
```java
    /**
     * 根据类型查询分类
     * @param type
     * @return
     */
    @GetMapping("/list")
    @ApiOperation("根据类型查询分类")
    public Result<List<Category>> list(Integer type) {
        List<Category> list = categoryService.list(type);
        return Result.success(list);
    }
```

>Service
```java
    /**
     * 根据类型查询分类
     *
     * @param type
     * @return
     */
    @Override
    public List<Category> list(Integer type) {
        List<Category> list = categoryMapper.list(type);
        return list;
    }
```

就到这了.分类接口写完,也全部测试通过.

