现代八股

# Redis篇

1. Redis使用场景
    - **缓存(穿透,击穿,雪崩 | 双写一致,持久化 | 数据过期,淘汰策略)**
    - **分布式锁(setnx,re'disson)**
    - 计数器
    - 保存token
    - 消息队列
    - 延迟队列

---

## 缓存穿透

![20230926101021](https://img01.zzmr.club/img/20230926101021.png)

例如,一个get请求: `api/new/getById/1`
![20230926101238](https://img01.zzmr.club/img/20230926101238.png)

**缓存穿透**:查询一个**不存在**的数据,mysql查询不到数据也不会直接写入缓存,就会导致每次请求都查数据库

*穿透穿透,可以理解为请求的数据穿透了redis,还是动用了mysql,导致缓存没起到作用*

**解决方案一**:缓存空数据,查询返回的数据为空,扔把这个空结果进行缓存
**优点**:简单
**缺点**:消耗内存,可能会发生不一致的问题

**解决方案二**:布隆过滤器
**优点**:内存占用较少,没有多余的key
**缺点**:实现复杂,存在误判
![20230926101827](https://img01.zzmr.club/img/20230926101827.png)

>**布隆过滤器**
bitmap(位图):相当于一个以(bit)位为单位的数组,数组中每个单元只能存储二进制数0或1
布隆过滤器的作用:布隆过滤器可以用于检索一个元素是否在一个集合中
![2023-09-26102348](https://img01.zzmr.club/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-26%20102348.png)
两种实现:redisson,guava

但是布隆过滤器也存在误判的可能
![20230926102614](https://img01.zzmr.club/img/20230926102614.png)
**误判率**:数组越小误判率就越大,数组越大误判率就越小,但是同时也带来了更多的内存消耗

## 缓存击穿

**缓存击穿**:给某**一个**key设置了过期时间,当key过期的时候,恰好这时间点对这个key有大量的并发请求过来,这些并发的请求可能会瞬间把DB压垮
![20230926125923](https://img01.zzmr.club/img/20230926125923.png)

两种解决方案
1. 互斥锁
![20230926123451](https://img01.zzmr.club/img/20230926123451.png)
2. 逻辑过期
    - 判断数据是否逻辑过期
    - 如已过期,获取互斥锁,开启新线程
        - 新线程中:查询数据库重建缓存数据
        - 写入缓存,重置逻辑过期时间
        - 释放锁
    - 返回过期数据(**注意,此时的返回数据,并不需要等待新线程执行完毕,而是直接返回**)
![20230926124730](https://img01.zzmr.club/img/20230926124730.png)

---

互斥锁和逻辑过期的比较
1. 互斥锁
    - 强一执
    - 性能差
2. 逻辑过期
    - 高可用
    - 性能优

## 缓存雪崩

**缓存雪崩**是指在**同一时段大量**的缓存key同时失效或者Redis服务宕机,导致大量请求到达数据库,带来巨大压力
![20230926130005](https://img01.zzmr.club/img/20230926130005.png)

解决方案
- 给不同的Key的TTL添加随机值
- 利用Redis集群提高服务的可用性(哨兵模式,集群模式)
- 给缓存业务添加降级限流的策略(nginx,spring cloud gateway)
- 给业务添加多级缓存(Guava,Caffenie)

**降级限流策略可作为系统的保底策略,适用于穿透,击穿,雪崩**

---

>缓存三兄弟
穿透无中生有key,布隆过滤null隔离
缓存击穿过期key,锁与非期解难题
雪崩大量过期key,过期时间要随机
面试必考三兄弟,可用限流来保底

## 双写一致

![20230926131024](https://img01.zzmr.club/img/20230926131024.png)

要结合业务背景,有两种情况
1. 一致性要求高
2. 允许延迟一致

### 一致性要求高

**双写一致性**,当修改了数据库的数据也要同时更新缓存的数据,缓存和数据库的数据要保持一致

![20230926125923](https://img01.zzmr.club/img/20230926125923.png)

- 读操作:缓存命中,直接返回;缓存未命中则查询数据库,写入缓存,设定超时时间
- 写操作:延迟双删

**先删除缓存,还是先修改数据库**
1. 先删除缓存
    - 正常情况:![20230926131855](https://img01.zzmr.club/img/20230926131855.png)
    - 异常情况,数据不一致(数据库和缓存中的数据不一致)![20230926131950](https://img01.zzmr.club/img/20230926131950.png)
2. 先操作数据库
    - 正常情况:![20230926132240](https://img01.zzmr.club/img/20230926132240.png)
    - 异常情况,数据不一致![20230926132414](https://img01.zzmr.club/img/20230926132414.png)

所以,无论是先删缓存,还是先修改数据库,都是会有问题的

这时采用**延迟双删**
![20230926132535](https://img01.zzmr.club/img/20230926132535.png)

**虽然还是有脏数据的风险罢了**

那有没有强一致性的解决方案呢?

**分布式锁**

或者说是读写锁,只针对于需要强一致性的场景,因为性能低
1. 共享锁:读锁readLock,加锁之后,其他线程可以继续共享读操作
2. 排他锁:独占锁writeLock也叫,加锁之后,阻塞其他线程读写操作
![20230926133140](https://img01.zzmr.club/img/20230926133140.png)

### 允许延迟一致

异步通知保证数据的最终一致性
![20230926133556](https://img01.zzmr.club/img/20230926133556.png)

基于Canal的异步通知
![20230926133620](https://img01.zzmr.club/img/20230926133620.png)

canal是基于mysql的主从同步来实现的
`二进制日志文件(BINGLOG)记录了所有DDL(数据定义语言)语句和DML(数据操作语言)语句,但不包括数据查询(SELECT,SHOW)语句`

![3123213213213213](https://img01.zzmr.club/img/3123213213213213.png)

## 持久化

![20230926221020](https://img01.zzmr.club/img/20230926221020.png)

1. RDB
2. AOF

### RDB

RDB全称Redis Database Backup file(Redis数据备份文件),也被叫做Redis数据快照,简单来说就是把内存中的所有数据都记录到磁盘中,当Redis实例故障重启后,从磁盘中读取快照文件,恢复数据
![20230926221331](https://img01.zzmr.club/img/20230926221331.png)

Redis内部也有触发RDB的机制,可以在redis.conf中找到,格式如下
```conf
save 900 1
save 300 10
save 60 10000
```

**RDB执行原理?**
bgsave开始时会fork主进程得到子进程,子进程**共享**主进程的内存数据,完成fork后读取内存数据并写入RDB文件

fork采用的是copy-on-write技术
- 当主进程执行读操作时,访问共享内存
- 当主进程执行写操作时,则会拷贝一份数据,执行写操作
![20230926222728](https://img01.zzmr.club/img/20230926222728.png)

### AOF

AOF全称为Append Only File(追加文件),Redis处理的每一个写命令都会记录在AOF文件,可以看作命令日志文件
![223022](https://img01.zzmr.club/img/223022.png)

AOF默认是关闭的,要在配置文件中开启
```conf
appendonly yes
```

AOF的同步频率设置
- appendfsync always 始终同步,每次Redis的写入都会立刻记入日志,性能较差但数据完整性比较好
- **appendfsync everysec** 每秒同步,每秒记入日志一次,如果宕机,本秒的数据可能丢失
- appendfsync no redis不主动进行同步,把同步时机交给操作系统

因为是记录命令,AOF文件会比RDB文件大的多,而且AOF会记录对同一个key的多次写操作,但只有最后一次写操作才有意义,通过执行`bgrewriteaof`命令,可以让AOF文件执行重写功能,用最少的命令达到相同的效果

```conf
# AOF文件比上次文件 增长超过多少百分比则触发重写
auto-aof-rewrite-percentage 100
# AOF文件体积最小多大以上才出发重写
auto-aof-rewrite-min-size 64mb
```

---

总结就是,RDB和AOF各有自己的优缺点,如果对数据安全性要求较高,在实际开发中往往会结合两者来使用(这和之前看的redis视频讲的差不多)
![20230926224811](https://img01.zzmr.club/img/20230926224811.png)

## 过期策略

![20230926225503](https://img01.zzmr.club/img/20230926225503.png)

### 惰性删除

Redis数据删除策略-惰性删除

惰性删除:设置该key过期时间后,我们不去管它,当需要该key时,我们在检查其是否过期,如果过期,我们就删掉它,反之就返回该key

**优点**:对CPU友好,只会在使用该key时才会进行过期检查,对于很多用不到的key不用浪费时间进行过期检查
**缺点**:对内存不友好,如果一个key已过期,但是一直没有使用,那么该key就会一直存在内存中,内存永远不会释放

### 定期删除

Redis数据删除策略-定期删除

定期删除:每隔一段时间,我们就对一些key进行检查,删除里面过期的key(从一定数量的数据库取出一定数量的随机key进行检查,并删除其中过期的key)

定期删除有两种模式
1. SLOW模式是定时任务,执行频率默认为10hz,每次不超过25ms,以通过修改配置文件redis.conf的hz选项来调整这个次数
2. FAST模式执行频率不固定,但两次间隔不低于2ms,每次耗时不超过1ms

**优点**:可以通过限制删除操作执行的时长和频率来减少删除操作对CPU的影响,另外定期删除,也能有效释放过期建占用的内存
**缺点**:难以确定删除操作执行的时长和频率

---

Redis的过期删除策略:惰性删除+定期删除两种策略进行配合使用

## 淘汰策略

![20230927085536](https://img01.zzmr.club/img/20230927085536.png)

**数据的淘汰策略**:当Redis中的内存不够用时,此时再向Redis总添加新的key,那么Redis就会按照某一种规则讲内存中的数据删除掉,这种数据的删除规则被称之为内存的淘汰策略

Redis支持8种不同的策略来选择要删除的key
- `noeviction`:不淘汰任何key,但是内存满时不允许写入新数据,默认就是这种策略
- `volatile-ttl`:对设置了TTL的key,比较key的剩余TTL值,TTL越小越先被淘汰
- `allkeys-random`:对全体key,随机进行淘汰
- `volatile-random`:对设置了TTL的key,进行随机淘汰
- `allkeys-lru`:对全体key,基于LRU算法进行淘汰
- `volatile-lru`:对设置了TTL的key,基于LRU算法进行淘汰
- `allkeys-lfu`:对全体key,基于LFU算法进行淘汰
- `volatile-lfu`:对设置了TTL的key,基于LFU算法进行淘汰

---

使用建议
1. 优先使用`allkeys-lru`策略,充分利用LRU算法的优势,把最近最长访问的数据流在缓存中,如果业务有明显的冷热数据区分,建议使用
2. 如果业务中数据访问频率差别不大,没有明显的冷热数据区分,建议使用`allkeys-random`,随机选择淘汰
3. 如果业务中有置顶的需求,可以使用`volatile-lru`策略,同时置顶数据不设置过期时间,这些数据就一直不被删除,会淘汰其他设置过期时间的数据
4. 如果业务中有短时高频访问的数据,可以使用`allkeys-lfu`或`volatile-lfu`策略

---

其他可能会问的问题
1. 数据库有1000万数据,Redis只能缓存20W数据,如何保证Redis种的数据都是热点数据?

**使用`allkeys-lru`(挑选最近最少未使用的数据淘汰)淘汰策略,留下来的都是经常访问的热点数据**

2. Redis的内存用完了会发生什么
主要看数据淘汰策略是什么,如果是默认的配置(`noeviction`),会直接报错

## 分布式锁

![20230927091744](https://img01.zzmr.club/img/20230927091744.png)

**当只有一台服务器时,使用`synchronized`解决是没问题的,但是当服务是多台服务器时,就不能使用了,还是需要外部锁的来解决**
![23-09-27092743](https://img01.zzmr.club/img/23-09-27092743.png)

**Redis分布式锁**
Redis实现分布式锁主要利用Redis的setnx命令,setnx是set if no exists(如果不存在,则set)

获取锁,NX是互斥,EX是设置过期时间
```redis
SET lock value NX EX 10
```
释放锁
```redis
DEL key
```

整体流程:
![20230927145211](https://img01.zzmr.club/img/20230927145211.png)

设置有效时长
![20230927145426](https://img01.zzmr.club/img/20230927145426.png)
1. 根据业务执行时间预估
2. 给锁续期

---

这时就要用到`redisson`来实现分布式锁

![123132150213](https://img01.zzmr.club/img/123132150213.png)

redisson实现的分布式锁-可重入
![20230927150634](https://img01.zzmr.club/img/20230927150634.png)


redisson实现的分布式锁-主从一致性(较少使用)
RedLock(红锁):不能只在一个redis实力上创建锁,应该是在多个redis实例上创建锁(n/2+1),避免在一个redis实例上加锁
![20230927151015](https://img01.zzmr.club/img/20230927151015.png)

- 实现复杂
- 性能差
- 运维繁琐

## 集群方案

![20230927151710](https://img01.zzmr.club/img/20230927151710.png)

- 主从复制
- 哨兵模式
- 分片集群

### 主从复制

单节点Redis的并发能力是有上限的,要进一步提高Redis的并发能力,就需要搭建主从集群,实现读写分离

![2023-09-27152040](https://img01.zzmr.club/img/2023-09-27152040.png)

**分为全量同步和增量同步**

增量同步:
![153922](https://img01.zzmr.club/img/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202023-09-27%20153922.png)

增量同步(slave重启或者后期数据变化):
![20230927154218](https://img01.zzmr.club/img/20230927154218.png)

回答案例:
![20230927154511](https://img01.zzmr.club/img/20230927154511.png)

### 哨兵模式

Redis提供了哨兵(Sentinel)机制来实现主从集群的自动故障恢复,哨兵的结构和作用如下
1. 监控:Sentinel会不端检查您的master和slave是否按预期工作
2. 自动故障恢复:如果master故障,Sentinel会将一个slave提升为master,当故障实例恢复后也以新的master为主
3. 通知:Sentinel充当Redis客户端的服务发现来源,当集群发生故障转移时,会将最新信息推送给Redis客户端
![20230927154951](https://img01.zzmr.club/img/20230927154951.png)

**服务转台监控**
Sentinel基于心跳机制监测服务状态,每隔1s向集群的每个实例发送ping命令
1. 主观下线:如果其sentinel节点发现某实例未在规定时间响应,则认为该实例**主观下线**
2. 客观下线:若超过指定数量(quorum)的sentinel都认为该实例主观下线,则该实例客观**下线**,quorum值最好超过Sentinel实例数量的一半
![20230927155336](https://img01.zzmr.club/img/20230927155336.png)

**下线后,哨兵就要选择一个从节点作为主节点**
1. 首先判断主与从节点断开时间长短,如超过指定值就排该从节点
2. 然后判断从节点的slave-priority值,越小优先级越高
3. **如果slave-prority一样,则判断slave节点和offset值,越大优先级越高**
4. 最后是判断slave节点的运行id大小,越小优先级越高

---

哨兵模式,可能存在的问题:**脑裂**
![20230927160007](https://img01.zzmr.club/img/20230927160007.png)

redis中有两个配置参数
`min-replicas-to-write 1`表示最少的slave节点为1个
`min-replicas-max-lag 5`表示数据复制和同步的延迟不能超过5秒

设置了这两个参数的,当主节点宕机,不达到这两个条件,是不会选择新的主机的.

### 分片集群结构

主从和哨兵可以解决高可用，高并发读的问题，但是依然有两个问题没有解决
- 海量数据存储问题
- 高并发写的问题

使用分片集群可以解决上述问题，分片集群特征
1. 集群中有多个master，每个master保存不同的数据
2. 每个master都可以有多个slave节点
3. master之间通过ping监测彼此健康状态
4. 客户端请求可以访问集群任意节点，最终都会被转发到正确节点
![20230927205512](https://img01.zzmr.club/img/20230927205512.png)

---

Redis分片集群引入了哈希槽的概念，Redis集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽,集群的每个节点负责一部分hash槽
![屏幕截图2023-09-27210240](https://img01.zzmr.club/img/屏幕截图2023-09-27210240.png)

## Redis其他问题

**Redis为什么这么快**
![20230927210522](https://img01.zzmr.club/img/20230927210522.png)

**I/O多路复用模型**
Redis是纯内存操作,执行速度非常快,它的性能瓶颈是**网络延迟**而不是执行速度,I/O多路复用模型主要就是实现了高校的网络请求

I/O多路复用是利用单个线程来同时监听多个Socket,并在某个Socket可读,可写时得到通知,从而避免无效的等待,充分利用CPU资源,不过监听Socket的方式,通知的方式又有多种实现,常见的有
1. select
2. poll
3. epoll

**差异**
- select和poll只会通知用户进程有Socket就绪,但不确定具体是哪一个Socket,需要用户进程逐个遍历Socket来确认
- epoll则会在通知用户进程Socket就绪的同时,把已就绪的Socket写入用户空间

![fdlkajlksfdjlkasf](https://img01.zzmr.club/img/fdlkajlksfdjlkasf.png)